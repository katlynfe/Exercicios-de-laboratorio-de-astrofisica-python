# -*- coding: utf-8 -*-
"""isis-katlyn_chapter2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nmxPEZOlMA9wUIuCSpxrx_uS7tcvwhNw

## Exercícios do capítulo 2.1

ASTRONOMIA ESFÉRICA

A distância angular da estrela do plano equatorial é chamada de declinação. Existe a interseção do plano equatorial com o plano do movimento orbital da Terra ao redor do Sol. O ponto de encontro dessa interseção com a eclíptica, é chamada de ascensão reta. O ponto zero da ascensão reta é conhecido como equinócio Vernal. O Sol muda de posição por conta da inclinação do eixo de rotação da Terra em respeito a direção perpendicular da eclíptica. O Sol terá declinação zero nos equinócios que ocorrem, geralmente em 20 de março, 22 de setembro e os solstícios em 20 de junho e 21 de dezembro. Para saber a declinação do Sol em dias gerias, utiliza-se arrays (matriz de uma linha). Chamar o array N[1] irá mostrar o primeiro elemento desse array. Chamar N[-3] irá mostrar o terceiro elemento de trás para frente do array. O movimento aparente de um objeto na esfera celeste é conhecido como o arco diurno. O tempo depende da posição do objeto no horizonte e é calculado pelo ângulo horário (1h = 15°). A distância entre o círculo que o objeto faz no céu para a eclíptica é a declinação do objeto. A distância do equador celeste para o eixo de rotação é a latitude. Para saber o dia sideral (T), multiplica 2 por hora angular e dividir por 360. Com comandos de plot é possível plotar um gráfico inserindo as informações desejadas no eixo x e y, e assim, cria-se uma imagem. Para descobrir a localização de determinado objeto no céu, utiliza-se a posição angular medida na direção normal do horizonte, a altitude (a), e a separação angular na direção paralela para o horizonte é o azimute (tudo isso no sistema horizontal).

### Exercício 2.1
"""

import math

# Declinação do Sol em funções trigonométricas para equinócios e solstícios

N = [79, 171, 265, 355]
ecli = math.radians(23.44)
omega = 2*math.pi/365.24
for i in N:
    decli = -math.asin(math.sin(ecli)*math.cos(omega*(i+10)))
    print("Declinação do Sol = {:.5f} degraus".format(math.degrees(decli)))

"""### Exercício 2.2"""

#exercicio 2.2

import math

#solstício N=355
#equinócio N =265
import datetime

equinocio_1 = datetime.date(2022, 3, 21) - datetime.date(2022, 1, 1)
dia_1 = equinocio_1.days
solsticio_1 = datetime.date(2022, 6, 21) - datetime.date(2022, 1, 1)
dia_2 = solsticio_1.days
equinocio_2 = datetime.date(2022, 9, 23) - datetime.date(2022, 1, 1)
dia_3 = equinocio_2.days
solsticio_2 = datetime.date(2022, 12, 22)- datetime.date(2022, 1, 1)
dia_4 = solsticio_2.days

dias = (dia_1, dia_2, dia_3, dia_4)

print("dias: ", dias)

inclinacoes = [0, 0, 0, 0]
ecl=math.radians(23.44)
omega = 2*math.pi/365.24

for i in range(0, 4):
   argumento_1 = omega*(dias[i]+10)
   fator_1 = math.cos(argumento_1)
   fator_2 = math.sin(ecl)
   argumento_2 = math.asin(fator_1*fator_2)
   inclinacoes[i] = math.degrees(-argumento_2)

print(inclinacoes)

"""### Exercício 2.3"""

# Para o primeiro solstício

import math
N = 171 #primeiro solstício
omega = 2*math.pi/365.24 #velocidade angular (rad/dia)
valor = (2*math.pi)/math.pi
ecli = math.radians(23.44) #obliquidade da ecliptica
e = 0.0167 #excentricidade da orbita da Terra
delta2 = -math.asin(math.sin(ecli)*math.cos(omega*(N+10)+e*valor*math.sin(omega*(N-2))))
print("declinação = {:.2f} degraus".format(math.degrees(delta2)))

# Fórmula da órbita circular para o 1º solstício

import math
N = 171
omega = 2*math.pi/365.24 #velocidade angular (rad/dia)
ecli = math.radians(23.44) #obliquidade da ecliptica
delta = -math.asin(math.sin(ecli)*math.cos(omega*(N+10)))
print("declinação = {:.2f} degraus".format(math.degrees(delta))) # para conferir o resultado

# Fórmula para órbita circular para equinócios e solstícios

import numpy as np
import math
N = np.array([79, 171, 265, 355])
omega = 2*math.pi/365.24 #velocidade angular (rad/dia)
ecli = math.radians(23.44) #obliquidade da ecliptica
e = 0.0167 #excentricidade da orbita da Terra
delta3 = -np.arcsin(math.sin(ecli)*np.cos(omega*(N+10)))
print(np.degrees(delta3)) # para conferir as declinações
print()

# Para os valores arredondados e fora do array
for val3 in delta3:
    print("declination = {:6.2f} deg".format(math.degrees(val3))) # para conferir os valores com os do array
print()

# Resultado em tabela para o delta3 (órbita circular para equinócios e solstícios)

print("i  day  delta3 [deg]")
for i,val3 in enumerate(delta3):
    print("{1:d}  {2:3d}  {0:8.2f}".format(math.degrees(val3),i,N[i]))

# Fórmula mais precisa para equinócios e solstícios

import numpy as np
import math
N = np.array([79, 171, 265, 355])
omega = 2*math.pi/365.24 #velocidade angular (rad/dia)
ecli = math.radians(23.44) #obliquidade da ecliptica
e = 0.0167 #excentricidade da orbita da Terra
delta4 = -np.arcsin(math.sin(ecli)*np.cos(omega*(N+10)+e*(2*math.pi/math.pi)*np.sin(omega*(N-2))))
print(np.degrees(delta4)) # para conferir as declinações
print()

# Para os valores arredondados e fora do array
for val4 in delta4:
    print("declination = {:6.2f} deg".format(math.degrees(val4))) # para conferir os valores como resultado obtido
print()

# Resultado em tabela para o delta4 (equação complexa para equinócios e solstícios)

print("i  day  delta4 [deg]")
for i,val4 in enumerate(delta4):
    print("{1:d}  {2:3d}  {0:8.2f}".format(math.degrees(val4),i,N[i]))

# Diferença entre as duas declinações para o 1º solstício

dif = delta2 - delta
print("Diferença = {:6.2f} degraus".format(math.degrees(dif)))
print()

# Desvio relativo das declinações para solstícios e equinócios
desvio = (delta3-delta4/delta4)*100

# apenas para conferir os dados com a tabela
for val5 in desvio:
    print(val5) # não precisa estar em degraus, pois é adimensional
print()

print("i  day   desvio [%]")
for i,val5 in enumerate(desvio):
    print("{1:d}  {2:3d}  {0:8.2f}".format(val5,i,N[i]))

"""### Exercício 2.4"""

#Exercicio 2.4

import astropy.units as u
import numpy as np
import math

from astropy.coordinates import SkyCoord, EarthLocation

#Calculando para Polaris
polaris = SkyCoord.from_name('Polaris')
print(polaris)

deltaP =polaris.ra
print("Longitude de Polaris (em graus)= ", deltaP.deg)

# Posição geográfica do observador em São Cristóvao

obsP = EarthLocation(lat = -10*u.deg + 55*u.arcmin + 56*u.arcsec,
                     lon= -37*u.deg + 4*u.arcmin + 23*u.arcsec)
phi = obsP.lat
print("Latitude do observador = ",phi)
a = EarthLocation(lat=90*u.deg, lon=0*u.deg)
lat90 = a.lat
print()
p = np.where(phi <= deltaP, lat90+phi-deltaP, lat90+phi+deltaP)
print("Altitude máxima da estrela Polaris (em graus) = ", p.deg)

#Calculando para Betelgeuse
betelgeuse = SkyCoord.from_name('Betelgeuse')
print(betelgeuse)

deltaB = betelgeuse.ra
print("Longitude de Betelgeuse (em graus)= ",deltaB.deg)

print("Latitude do observador = ",phi)
b = np.where(phi <= deltaB, lat90+phi-deltaB, lat90+phi+deltaP)
print("Altitude máxima de Betelgeuse (em graus) = ", b.deg)
print()

#Calculando para Rigel
rigel = SkyCoord.from_name('Rigel')
print(rigel)

deltaR = rigel.ra
print("Longitude de Rigel (em graus) = ",deltaR.deg)

print("Latitude do observador = ",phi)
r = np.where(phi <= deltaR, lat90 + phi-deltaR, lat90+phi+deltaR)
print("Altitude máxima de Rigel (em graus) = ", r.deg)
print()

#Calculando para SiriusA
siriusA = SkyCoord.from_name('Sirius A')
print(siriusA)

deltaS = siriusA.ra
print("Longitude de Sirius A (em graus)=  ",deltaS.deg)

print("Latitude do observador = ",phi)
s = np.where(phi <= deltaS, lat90 + phi-deltaS, lat90+phi+deltaS)
print("Altitude máxima de Sirius A (em graus)= ", s.deg)

"""### Exercício 2.5"""

#dia sideral

import math
import astropy


#dia sideral é 3'56'' mais curto que um dia solar de 24h

x = 3*60 + 56
dia_sid_s = 24 * 3600 - x
dia_sid = dia_sid_s / 3600

#orbita da Terra em dias solares = 365
orb_Sol = 365
dia_sol = 24

orb_sid =(orb_Sol*dia_sid)/dia_sol
print("Dia Sideral= ", orb_sid)

T = (orb_Sol)/(orb_Sol + orb_Sol/orb_sid)

print("T={:} h".format(T))

#Usando a fórmula do livro:
#Sendo 1 hora = 15 graus
h = 15
T1= ((h)/360)* dia_sid

print("T={:} h".format(T1))
#T = 0.9973 = 1**h

"""### Exercício 2.6"""

import astropy.units as u
import math
import numpy as np
import matplotlib.pyplot as plt
from astropy.coordinates import SkyCoord, EarthLocation, AltAz, get_sun
from astropy.time import Time

#formula da questão 2.3
N1 = np.arange(365)
omega = 2*math.pi/365.24
e = 0.0167
ecl = math.radians(23.44)
valor = 2*math.pi/math.pi
t = []

#observador em Aracaju
#localização(lat=-10*u.deg + 55*u.arcmin + 56*u.arcsec, lon=-37*u.deg + 54*u.arcmin + 34*u.arcsec)

lat= math.radians(-10 + 55/60 + 56/(3600))

# approximação para a declinação do Sol

delta2 = -np.arcsin(np.sin(ecl)*np.cos(omega*(N1+10) + e*valor*np.sin(omega*(N1-2))))

h = np.arccos(-np.tan(delta2) * np.tan(lat))
T = (np.degrees(2*h)/360) * u.sday.to(u.h)
t.append(T)

plt.plot(N1, T)
plt.xlabel("Day")
plt.ylabel("Day [hr]")
print("Minimum day length = {:5.2f} h".format(T.min()))
print("Maximum day length = {:5.2f} h".format(T.max()))

desvio = (T.max()-T.min())/T.max()
print("Desvio encontrado: ", desvio)

#Diferença da figura 2.5
#Pela figura 2.5 é possível observar que a diferença do desvio relacionada a
#outras cidade se dá pela sua latitude ser negativa devida sua localização no mapa
#Ao ser plotado junto com outras cidade o eixo é possível observar que o eixo relacionado aos dias(y)
#está no mesmo intervalo que o do gráfico da figura 2.6

"""### Exercício 2.7"""

# Janela de observação de astros

import astropy.units as u
from astropy.coordinates import SkyCoord, EarthLocation, AltAz, get_sun

# Localização de Hamburg Observatory
obs = EarthLocation(lat = 53*u.deg + 28*u.arcmin + 49*u.arcsec,
                   lon=10*u.deg + 14*u.arcmin + 23*u.arcsec)

# Latitude
phi = obs.lat


# Horário de acordo com as coordenas universais de tempo
from astropy.time import Time

# Fuso horário do Brasil (-3h)
utc_shift = -3*u.hour

# mostra o tempo correspondente a 12 horas de acordo com o fuso horário
# para a véspera de ano novo
noon_brt = Time("2022-12-31 12:00:00") - utc_shift
print(noon_brt)

import numpy as np

# Denifição das coordenadas horizontais

# Array de repartição de 24 horas
elapsed = np.arange(0, 24*60, 5)*u.min
time = noon_brt + elapsed

# Divisão do céu em quadros (frames) para saber a janela de observação
frame_local_24h = AltAz(obstime=time, location=obs)

# Commented out IPython magic to ensure Python compatibility.
# Para Betelgeuse (quem quero observar)
betelgeuse = SkyCoord.from_name('Betelgeuse')

betelgeuse_local = betelgeuse.transform_to(frame_local_24h)
# transform_to transforma a declinação e ascensão reta em altitude e azimute para os quadros denifidos

# posição do Sol nesses quadros em sistemas equatoriais
sun = get_sun(time)

sun_local = sun.transform_to(frame_local_24h)

# Denifindo a altitude de Betelgeuse e o Sol para o intervalo e local escolhidos em gráfico
import matplotlib.pyplot as plt
# %matplotlib inline

elapsed_night = elapsed[np.where(sun_local.alt < 0)]
betelgeuse_noite = betelgeuse_local.alt[np.where(sun_local.alt < 0)]

# Altitude do Sol
plt.plot(elapsed.to(u.h), sun_local.alt, color='yellow', label='Sol')

# Altitude Betelgeuse (noite)
plt.plot(elapsed_night.to(u.h), betelgeuse_noite, color='purple', label='Betelgeuse (noite)')

# Altitude Betelgeuse (dia)
plt.plot(elapsed.to(u.h), betelgeuse_local.alt, color='black', linestyle=':', label='Betelgeuse (dia)')

plt.xlabel('Tempo a partir do meio dia [h]')
plt.xlim(0, 24)
plt.xticks(np.arange(13)*2)
plt.ylim(0, 80)
plt.ylabel('Altitude [deg]')
plt.legend(loc='upper center')

# Para a minha localidade

# Minha localização
obs_eu = EarthLocation(lat=-10*u.deg+-54*u.arcmin-39*u.arcsec,
                    lon=-37*u.deg-4*u.arcmin-23*u.arcsec)

# Latitude
phi = obs_eu.lat

# Fuso horário do Brasil (-3h)
utc_shift = -3*u.hour

# mostra o tempo correspondente a 12 horas de acordo com o fuso horário
# para a próxima noite
noon_brt2 = Time("2022-07-30 12:00:00") - utc_shift
print(noon_brt2)

# Array de repartição de 24 horas
elapsed2 = np.arange(0, 24*60, 5)*u.min
time2 = noon_brt2 + elapsed2

# Divisão do céu em quadros (frames) para saber a janela de observação
frame_local_24h2 = AltAz(obstime=time2, location=obs_eu)

# Betelgeuse, Polaris e Sirius A

# transform_to transforma a declinação e ascensão reta em altitude e azimute para os quadros denifidos
# Betelgeuse
betelgeuse = SkyCoord.from_name('Betelgeuse')
betelgeuse_local = betelgeuse.transform_to(frame_local_24h2)

# Polaris
polaris = SkyCoord.from_name('Polaris')
polaris_local = polaris.transform_to(frame_local_24h2)

# Sirius A
sirius_a = SkyCoord.from_name('Sirius A')
sirius_local = sirius_a.transform_to(frame_local_24h2)

# posição do Sol nesses quadros em sistemas equatoriais
sol = get_sun(time2)

sol_local = sol.transform_to(frame_local_24h2)

# Commented out IPython magic to ensure Python compatibility.
# Denifindo a altitude das estrelas para o intervalo e local escolhidos em gráfico
import matplotlib.pyplot as plt
# %matplotlib inline

elapsed_noite = elapsed[np.where(sol_local.alt < 0)]
betelgeuse_noite = betelgeuse_local.alt[np.where(sol_local.alt < 0)]
polaris_noite = polaris_local.alt[np.where(sol_local.alt < 0)]
sirius_noite = sirius_local.alt[np.where(sol_local.alt < 0)]

# Altitude do Sol
plt.plot(elapsed.to(u.h), sol_local.alt, color='yellow', label='Sol')

# Altitude Betelgeuse (noite)
plt.plot(elapsed_noite.to(u.h), betelgeuse_noite, color='purple', label='Betelgeuse (noite)')

# Altitude Betelgeuse (dia)
plt.plot(elapsed.to(u.h), betelgeuse_local.alt, color='purple', linestyle=':', label='Betelgeuse (dia)')

# Altitude Polaris (dia)
plt.plot(elapsed.to(u.h), polaris_local.alt, color='blue', linestyle=':', label='Polaris (dia)')

# Altitude Polaris (noite)
plt.plot(elapsed_noite.to(u.h), polaris_noite, color='blue', label='Polaris (noite)')

# Altitude Sirius A (dia)
plt.plot(elapsed.to(u.h), sirius_local.alt, color='green', linestyle=':', label='Sirius A (dia)')

# Altitude Sirius A (noite)
plt.plot(elapsed_noite.to(u.h), sirius_noite, color='green', label='Sirius A (noite)')

# eixos do gráfico
plt.xlabel('Tempo a partir do meio dia [h]')
plt.xlim(0, 24)
plt.xticks(np.arange(13)*2)
plt.ylim(0, 90)
plt.ylabel('Altitude [deg]')
plt.legend(loc='upper center')

"""Pelo gráfico acima, as estrelas Betelgeuse e Sirius A estão visíveis para o dia e noite do dia 29/07/2022. No entanto, a estrela mais visível e por um maior período de tempo é Sirius A.

## Exercícios leis de Kepler do movimento planetário

- 1ª lei: os planetas se movem órbitas elípticas onde o Sol se localiza em um dos pontos focais
- 2ª lei: a área varrida por um vetor radial do Sol ao planeta é proporcional ao tempo decorrido
- A fórmula geral para um período P do movimento do planeta na órbita elíptica ao redor da estrela é: P² = [4(pi)²/(G(M+m))]a³ onde a é o semi-eixo maior da órbita, G é a constante gravitacional, M a massa da estrela e m a massa do planeta. Se a massa do planeta é muito inferior à massa da estrela, isto é, m<<M, a massa do planeta é desprezada e considera-se apenas a massa da estrela para o cálculo. Nesse caso, o semi-eixo maior é igual ao raio.
- 3ª lei: relação entre o semi-eixo maior e o período orbital.

### Exercício 2.8
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import numpy as np
from scipy.constants import year,hour,au,G
from astropy.constants import M_sun
import matplotlib.pyplot as plt
# %matplotlib inline

M = M_sun.value # massa do Sol em KG

# órbita dos planetas
# massa em Kg
#como a massa dos planetas anões são insignificantes, adotei m = 1

# semi-eixo maior em m
m = 1e24*np.array([0.33011, 4.8675, 5.9723, 0.64171, 1898.19, 568.34, 86.813, 102.413, 0.001, 0.001, 0.001])

# Plutão (a = 39,48 UA), 21 Ceres (a = 2,7675 UA), Eris (a = 67.781 AU).
a = 1e9*np.array([57.9, 108.21, 149.60, 227.92, 778.57, 1433.53, 2872.46, 4495.06, 39.48, 2.7675, 67.781])
print("semi-eixo maior = ",a)
print()

# use Kepler's third law to calculate period in s
T_test_mass = 2*math.pi * (G*M)**(-1/2) * a**(3/2)
T_two_body = 2*math.pi * (G*(M + m))**(-1/2) * a**(3/2)

# use Kepler's third law to calculate period in s
print("T [yr]  dev [hr] dev rel.")
for val1,val2 in zip(T_test_mass,T_two_body):
    dev = val1 - val2
    if dev > hour:
        line = "{0:6.2f}  {1:<7.1f}  {2:.1e}"
    else:
        line = "{0:6.2f}  {1:7.4f}  {2:.1e}"
    print(line.format(val2/year, dev/hour, dev/val1))

fig = plt.figure()
fig.set_size_inches(5,8)
plt.loglog(a/au, T_test_mass/year, 'b--', label='massa teste')
plt.loglog(a/au, T_two_body/year, 'ro', label='planetas')
plt.loglog(a[8:]/au, T_two_body[8:]/year, 'o', color='pink', label='planetas anões')
plt.legend(loc='lower right')
plt.xlabel("semi-eixo maior [AU]")
plt.ylabel("período orbital [dias]")

"""### Exercício 2.9"""

# Commented out IPython magic to ensure Python compatibility.
# Parte 1:
# Semi-eixo maior dos Júpiteres Quentes

import math
import numpy as np
from astropy.constants import M_sun
from scipy.constants import au,G

# Massa dos Jupiteres quentes em kg
# 1.898*10**30 é a massa de Jupiter, pois a massa é dado em relação\
# a ele
m = np.array([22, 8.4, 0.94, 0.92, 3.19, 0.56, 1.77]) * 1.898*10**30

# Massa em relação a estrela que orbita
# 1.988*10**30 é a massa do Sol
M = np.array([1.37, 1.51, 1.17, 0.73, 0.79, 1.45, 1.29]) * M_sun.value

# Período em dias para segundos (86400)
P = np.array([4.257, 6.790, 1.721, 6.088, 3.093, 4.954, 1.549])*86400

# Cálculo do semi-eixo maior dos Jupiteres quentes
# Dada em metros
a = (1e9*np.array(10**(3*np.log(P)/2)))/au

# Gráfico de período orbital X semi-eixo maior

import matplotlib.pyplot as plt
# %matplotlib inline

# não entendo porquê a linha pontilhada vira uma reta em\
#determinado intervalo se eu só pedi para exibir a relação\
#de período e semi-eixo

plt.figure(figsize=(5,4))
plt.title("Relação de período e semi-eixo maior")
plt.loglog(a/au, P/86400, 'green', linestyle='--', label='log de P vs a')
plt.loglog(a/au, P/86400, 'ro',label='Jupiteres quentes')
plt.legend(loc='lower right')
plt.xlabel("Semi-eixo maior [AU]")
plt.ylabel("Perído orbital [d]")

plt.savefig("PeriodoXa-jupiteres-quentes.pdf")

# Tabela
print("Tabela de valores de período orbital, massa dos jupiteres quentes, semi-eixo maior e massa da estrela:")
print()
print("T [d]     m [kg]    a [au]    M [kg]")
for val1,val2,val3,val4 in zip(P, m, a, M):
    line = "{:3.1e}   {:3.1e}   {:3.1e}  {:3.1e}".format(val1,val2,val3,val4)
    print(line)

# Parte 2:

# último argumento é o grau da função (linear)
# a já é dado em unidades astronomicas
# P é convertido para dias
x = np.polyfit(np.log(P/86400), np.log(a), 1)
print(x)
print(x[0])

# x = P/dias e y = a/au
# x[0]=c0 pega o primeiro valor de x e x[1]=c1 pega o segundo
a1 = x[1]*P + x[0]
print(a1)

# Essa formulação é muito similar a fórmula de logaritmo do período
# log P = 3/2(log a) + cte
# onde esta última é uma função linear também

# Gráfico utilizando o novo semi-eixo a1 usando valores do polifit

plt.figure(figsize=(5,4))
plt.title("Gráfico linear relacionando o semi-eixo corrigido e o período")
plt.loglog(a1, P/86400, 'blue',linestyle='--',label='função com semi-eixo corrigido')
plt.loglog(a1, P/86400, 'ro',label='Jupiteres quentes')
# o período deve ser pasado para dias
# o semi-eixo já está em au

plt.legend(loc='lower right')
plt.xlabel("Semi-eixo maior [AU]")
plt.ylabel("Perído orbital [d]")

# Gráfico para relacionar os dois resultados obtidos

plt.figure(figsize=(7,6))
plt.title("Relação dos dois gráficos (diferentes semi-eixos)")
plt.loglog(a/au, P/86400, 'green', linestyle='--', label='P vs a')
plt.loglog(a/au, P/86400, 'ro',label='Jupiteres quentes')
plt.loglog(a1, P/86400, 'blue',linestyle='--',\
           label='função com semi-eixo corrigido')
plt.loglog(a1, P/86400, 'ro',label='Jupiteres quentes')
plt.legend(loc='upper left')
plt.xlabel("Semi-eixo maior [AU]")
plt.ylabel("Perído orbital [d]")

"""Relação c1 e 3/2

    3.45387764 é o valor de c1. Comparando as equações 2.5 e a função linear com c0 e c1, entende-se que c1 representa o valor de 3/2 e 34.25138849 representa a constante. No entanto, c1 é maior que 3/2 e isso impacta na reprodução do gráfico. A função polyfit calcula um polinômio através do método dos míminos quadrados, variando conforme o polinômio tratado. Ele pode ser considerado mais estável que a equação 2.5, pois ela, além de estar incorreta, será a mesma fórmula independente dos valores e não irá variar como a função varia considerando as estradas inseridas nela.

### Exercício 2.10
"""



"""## Exercícios de forças de maré

- A dependência da força gravitacional pela distânica gera as forças de maré entre diferentes partes do corpo em questão.
- A força de maré para diferentes pontos de um planeta é dada pela diferença da força em relação ao centro de massa.
- A magnitude da força de maré cresce com a distância do centro da Terra.
- Protuberâncias de marés são criadas em um corpo devido a força de maré agindo nele. A Terra é aproximadamente um corpo rígido e as produberâncias são induzidas na água dos oceanos, gerando enchentes e marés baixas.

### Exercício 2.11
"""

import numpy as np
from scipy.constants import g,G
from astropy.constants import R_earth,M_earth, M_jup, R_jup

# Para sistema Terra-Lua

# Massa da Lua em kg
M_lua = 0.07346e24

# semi-eixo maior da órbita da Lua em metros
r_lua = 3.844e8

# 2GMR/r³ -> módulo da aceleração de maré para a órbita circular
a_tl = 2*G*M_lua*R_earth.value*(r_lua)**(-3)
print("Aceleração de maré Terra-Lua = {:.2e} m/s² ou {:.2e} g".format(a_tl,a_tl/g))
# em termos de aceleração e aceleração da gravidade g

# Altura do bojo de maré
h = (15*M_lua*R_earth.value**4)/(8*M_earth.value*r_lua**3)
print("Tamanho do bojo de maré Terra-Lua = {:.2f} m".format(h))

# Para sistema Júpiter-Io

# Massa Io em kg
M_io = 8.9319e22

# semi-eixo maior da órbita de Io em metros
r_io = 4.217e5

# Aceleração de maré para a órbita circular
a_ju = 2*G*M_io*R_jup.value*(r_io)**(-3)
print("Aceleração de maré Jupiter-Io = {:.2e} m/s² ou {:.2e} g".format(a_ju,a_ju/g))
# em termos de aceleração e aceleração da gravidade g

# Altura do bojo de maré
h = (15*M_io*R_jup.value**4)/(8*M_jup.value*r_io**3)
print("Tamanho do bojo de maré Júpiter-Io = {:.2e} m".format(h))

# Módulo da aceleração

# aceleração de maré para Terra-Lua
a_terra = G*M_lua/r_lua**3

# Posição em coordenadas para cobrir o diâmetro da Terra
# essa função considera o intervalo de entrada (-1.1) e
# de saída (1.1) com 23 espaçamentos entre eles
# (o número inicial e final conta nesse intervalo)
X = np.linspace(-1.1, 1.1, num=23, endpoint=True)
Y = np.linspace(-1.1, 1.1, num=23, endpoint=True)

# cria uma combinação entre x e y em uma malha
# bidimensional (23X23), considerando o raio da Terra
R_x, R_y = np.meshgrid(R_earth.value*X, R_earth.value*Y)

# Distancia radial
R1 = np.sqrt(R_x*R_x + R_y*R_y)

# Aceleração de maré com o raio da Terra
a_x = np.ma.masked_where(R1 > R_earth.value, 2*a_terra*R_x)
a_y = np.ma.masked_where(R1 > R_earth.value, -a_terra*R_y)


# Aceleração de maré para Jupiter-Io
a_jup = G*M_io/r_io**3
A = np.linspace(-1.3, 1.3, num=23, endpoint=True)
B = np.linspace(-1.3, 1.3, num=23, endpoint=True)

# cria uma combinação entre x e y em uma malha
# bidimensional (23X23), considerando o raio da Terra
R_a, R_b = np.meshgrid(R_jup.value*A, R_jup.value*B)

# Distancia radial
R2 = np.sqrt(R_a*R_a + R_b*R_b)

# Aceleração de maré com o raio da Terra
a_a = np.ma.masked_where(R2 > R_jup.value, 2*a_jup*R_a)
a_b = np.ma.masked_where(R2 > R_jup.value, -a_jup*R_b)

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
# %matplotlib inline

# Figura para aceleração de maré da Terra
fig, ax = plt.subplots(figsize=(6,6),dpi=100)
ax.set_aspect('equal')

# Vetor de plotagem chazmando as coordenadas criadas
# e a malha bidimensional de aceleração
arrows = ax.quiver(X, Y, a_x, a_y, color='blue')

# coloca o círculo azul
coeff = G*M_lua/r_lua**3
accel_scale = 2*coeff*R_earth.value

# aceleração obtida para Terra
ax.quiverkey(arrows, X=0.1, Y=0.95, U=accel_scale,
             label=r'$1.1\times 10^{-6}\;\mathrm{m/s}^2$',
             labelpos='E')

# Coloca um círculo na figura
circle = Circle((0, 0), 1, alpha=0.2, edgecolor=None)
ax.add_patch(circle)

ax.set_xlabel(r'$x/R_{\mathrm{E}}$', fontsize=12)
ax.set_ylabel(r'$y/R_{\mathrm{E}}$', fontsize=12)

# Commented out IPython magic to ensure Python compatibility.

import matplotlib.pyplot as plt
from matplotlib.patches import Circle
# %matplotlib inline

# Figura da aceleração de maré para Júpiter

fig, ax = plt.subplots(figsize=(7,7),dpi=100)
ax.set_aspect('equal')

# Vetor de plotagem chazmando as coordenadas criadas
# e a malha bidimensional de aceleração
arrows = ax.quiver(A, B, a_a, a_b, color='blue')

# coloca o círculo azul (accel_scale)
coeff = G*M_io/r_io**3
accel_scale = 2*coeff*R_jup.value

# aceleração obtida para Terra
ax.quiverkey(arrows, X=0.1, Y=0.95, U=accel_scale,
             label=r'$1.1\times 10^{-6}\;\mathrm{m/s}^2$',
             labelpos='E')

# Coloca um círculo na figura
circle = Circle((0, 0), 1, alpha=0.2, edgecolor=None)
ax.add_patch(circle)

ax.set_xlabel(r'$x/R_{\mathrm{E}}$', fontsize=12)
ax.set_ylabel(r'$y/R_{\mathrm{E}}$', fontsize=12)

"""### Exercício 2.12"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from scipy.constants import g,G
from astropy.constants import R_earth,M_earth, c
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
# %matplotlib inline

#letra a)
#considerando uma massa despresivel
r = 1 #m
m = 1

#Força de tração
F_earth = (G*M_earth*R_earth*1e3/r**3)*(2*np.cos(0), -np.sin(0))
print("Força de Tração em relação a Terra = {:} Nm^2".format(F_earth))

#Para uma anã branca de massa solar
M_sun = 1.98840987e30 #Kg
M_ana = 1*M_sun #Kg

#Considerando R = 5800 km
R_ana = 5800*1e3 #m

#Força de tração exercida pela anã branca
F_ana = np.array(G*M_ana*R_ana/r**3)*(2*np.cos(0), -np.sin(0))
print("Força de Tração em relação a Anã Branca = {:} Nm^2".format(F_ana))

#Considerando um buraco negro
#buraco negro com massa M = 10 Msolar
M_bn = 10*M_sun

#Raio do horizonte de eventos
R_bn = 2*G*M_bn/c**2

#Força de tração exercida pelo buraco negro
F_bn = np.array(G*M_bn*R_bn*1e3/r**3)*(2*np.cos(0), -np.sin(0))
print("Força de Tração em relação ao Buraco Negro = {:} Nm^2".format(F_bn))

# Commented out IPython magic to ensure Python compatibility.
#letra b)
import numpy as np
from scipy.constants import g,G
from astropy.constants import R_earth,M_earth, c
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
# %matplotlib inline

#diaâmetro da haste
r= 2.5*10**-2 #m

#Densidade
d = 7.8 #g/cm**3

#resistência de escoamento
r_e = 5*1e8 #N/m

#Força máxima é a densidade vezes a área
area = np.pi*r**2
F = r_e**area
print("Força máxima que a haste suporta = {:} N".format(F))

#Força de tração exercida pelo buraco negro
r = np.array(((G*M_bn*R_bn*(2*np.cos(0), -np.sin(0)))/F)**1/3)
print("Raio máximo em relação ao Buraco Negro = ",r)
print()

r_2 = np.array(((G*M_bn*R_bn*(2*np.cos(0), -np.sin(0)))/981)**1/3)
print("Raio máximo p/ aproximadamente 1000N em relação ao Buraco Negro = ",r_2)
print()
#Foi usado 100kg * 9.81 = F