# -*- coding: utf-8 -*-
"""isis_katlyn_chapter3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B2ywEmvH2N44N9x9JbAIkdhNs3yqaN_0

## Exercícios do capítulo 3.1

## Radiação de Corpo Negro e prorpiedades estelares

### Lei de Stefan-Boltzmann

- A luz emitida por uma estrela é aproximadamente descrita pela radiação de um corpo negro.
- Lei de Stefan-Boltzmann: a energia total emitida por um corpo negro por uniddade de tempo está relacionada com a área da superfície e a temperatura.
- A distribuição da radiação emitida é dada pela função de Planck.
- A caracterização de uma estrela pode ser feita pela sua temperatura efetiva e luminosidade (radiação emitida por tempo): F = sigmaxTeff⁴ (lei de Stefan-Boltzmann) (sigma = 5.670x10⁻⁸ W/m²K⁴).
- Através dessa lei, pode-se obter a luminosidade: L = A x F = 4 x pi x R² x sigma x Teff⁴
- O fluxo é dado em unidades de potência por área (W/m²) e a luminosidade é dada em potência (watts = W) ou ergs por segundo (erg/s).
- No SI, o raio é dado em metros e a temperatura efetiva em Kelvins.

### Espectro de Planck

- Função de Planck: B_lambda(T) = 2 x h x c²/(lambda⁵ x exp(h x c/lambda x k x T) - 1), sendo lambda o comprimento de onda, h a constante de Planck, k a constante de Boltzmann e c a velocidade da luz no vácuo.
- O diferencial B_lambda(T) x cos(teta) x d(ômega) x d(lambda) é a energia por área e unidade de tempo sobre o ângulo (teta) na superfície normal ao ângulo sólido d(ômega) = sen(teta) x d(teta) x d(phi)
- Lei de Wien: lbd_max = b/T, sendo b ~ h x c/4.965114 k -> b = 0.002897772 m K

### Exercício 3.1
"""

# Commented out IPython magic to ensure Python compatibility.
#calcule o raio para determinada luminosidade e temperatura efetiva
#definindo a função de raio
#letra a
from math import pi
from scipy.constants import sigma
import numpy as np
from math import pi
from astropy.constants import R_sun, L_sun, sigma_sb
import astropy.units as unit
from astropy.constants import M_sun
import matplotlib.pyplot as plt
# %matplotlib inline


def raio(L, Teff):
    """
    function computes luminosity of star
    using the Stefan-Boltzmann law with units

    args: dimensinoal variables based on astropy.units
          R - radius
          Teff - effective temperature

    returns: luminosity
    """
    b = np.sqrt(L/(4*pi*sigma_sb* Teff**4)) # local variable for surface area
    return b

#Criando a função de parametros para as estrelas
def stellar_parameters1(*args):
    '''
    auxiliary function to create a dictionaries
    of stellar parameters in SI units

    args: (radius, effective temperature)
    '''
    return { "L"    : args[0],
             "Teff" : args[1],
             "Mass" : args[2]}

# dicionario de estrelas, adicionando (Aldebaran e Bellatrix)
stars1 = {
    'Bernard\'s Star' :
        stellar_parameters1(3.3e-03*L_sun, 3.13e3*unit.K, 0.144*M_sun),
    'Sirius A' :
        stellar_parameters1(2.6e+01*L_sun, 9.94e3*unit.K, 2.06*M_sun),
    'Sirius B' :
        stellar_parameters1(2.4e-02*L_sun, 2.48e4*unit.K, 1.02*M_sun),
    'Arcturus' :
        stellar_parameters1(2.0e+02*L_sun, 4.29e3*unit.K, 1.1*M_sun),
    'Betelgeuse' :
        stellar_parameters1(1.3e+05*L_sun, 3.59e3*unit.K, 12*M_sun),
    'Aldebaran' :
        stellar_parameters1(4.4e+2*L_sun, 3.9e3*unit.K, 1.2*M_sun),
    'Bellatrix' :
        stellar_parameters1(9.21e+2*L_sun, 2.2e4*unit.K, 8.6*M_sun)}

for name in stars1:
    stars1[name]['R'] = raio(stars1[name]['L'], stars1[name]['Teff'])
    print("\t{:15s} {:.1e} {:.1e} {:.1e} {:.1e}".format(name, stars1[name]['Mass'], stars1[name]['R'], stars1[name]['Teff'], stars1[name]['L']))

#letra b
#plotando o gráfico da luminosidade vs a temperatura efeitva
# plot fraction of all hydrogen in first excited state
#gigantes vermelhas= aldebaran e betelgeuse
#anã branca = siriusB

for name1 in stars1:
    stars1[name1]['R'] = raio(stars1[name1]['L'], stars1[name1]['Teff'])
    if stars1[name1]['R'] <= 1e+07*unit.m:
        plt.loglog(stars1[name1]['Teff'], stars1[name1]['L']/L_sun, 'o', color='red', label='Anã branca')
    elif stars1[name1]['R'] >= 2e+10*unit.m:
        plt.loglog(stars1[name1]['Teff'], stars1[name1]['L']/L_sun, 'o', color='pink', label='Gigante Vermelha')
    else:
        plt.loglog(stars1[name1]['Teff'], stars1[name1]['L']/L_sun, 'o', color='blue', label='Estrelas da sequência principal')
        plt.xlabel("$Teff$ [K]")
        plt.ylabel("$Luminosuidade/L_sun$ [W]")
        """Mudando os limites do gráfico no eixo X, tendo em vista que no diagrama HR ele a Temperatura Efetiva
        é representada do  maior para o menor"""
        plt.xlim(30000,3000)
        plt.legend(loc = 2, bbox_to_anchor = (1,1,))

# Commented out IPython magic to ensure Python compatibility.
#letra c
#um gráfico de luminosidade vs massa em escala logarítmica dupla
import matplotlib.pyplot as plt
# %matplotlib inline
for name1 in stars1:
    plt.loglog(stars1[name1]['Mass'], stars1[name1]['L']/L_sun, 'o', color='blue')
    plt.xlabel("$Massa$ [Kg]")
    plt.ylabel("$Luminosuidade/L_sun$ [W]")

"""A relação que se dá é de que a massa é diretamente proporcional a sua luminosidade,
ou seja, quando aumenta a massa da estrela a sua energia emitida como radiação por unidade de tempo
também irá aumentar.
"""

"""### Exercício 3.2"""

# Para saber a distância considenrando a extinção, usa o root

def root_bisection(f, a, b, eps=1e-3, verbose=False):
    i = 0 # 0 iterações

    # separação dos pontos finais maior que a tolerância
    while abs(b-a) > eps:

        if verbose:
            print(f"{a:6.3f} {f(a):10.3e}",
                  f"{b:6.3f} {f(b):10.3e}")

        # ponto médio
        x = 0.5*(a+b)

        # verifique se a função cruza zero no subintervalo \
        #esquerdo # e redefina o endpoint, a menos que x \
        # seja a solução exata
        if f(x) == 0:
            print("found exact solution " + \
                  "after {:d} iteration(s)".format(i+1))
            return x
        elif f(a)*f(x) < 0:
            b = x
        else:
            a = x

        # incremento do contador para continuidade
        i += 1

    #print("tolerance reached after {:d} iterations".format(i))
    #print("deviation: f(x) = {:.3e}".format(f(x)))

    return x

import astropy.units as unit
import numpy as np
import matplotlib.pyplot as plt

# Cálculo da distância de estrelas em pc

# Magnitude absoluta
M = -4.0
print("Distância de estrelas tipo B0 na banda visual:")
print("\n r (pc)")


r_pc = []
magn = []
m = np.linspace(-4,6,101)

# magnitude aparente para o intervalo desejado
for mag in m:
  r_pc.append(10**((mag-M+5)/5))
  magn.append(mag)

print("{}".format(r_pc))
print()

np.array(r_pc)
np.array(magn)


plt.plot(magn,r_pc,linestyle='dotted')
plt.xlabel('Magnitude')
plt.ylabel('Distância [pc]')
plt.title('Distância X Magnitude (sem extinção interestelar)')

import matplotlib.pyplot as plt

# definindo a função de distância considerando a extinção para\
# aplicar a bissecção


k = 2*10**(-3)
M = -4
m = np.linspace(-4,6,101)


def r(r):
    return 5*np.log10(r/10) + k*r - mag + M

dist = []
mg = []

for mag in m: # magnitude aparente na banda visual
  dist.append(root_bisection(r, 1, 30000))
  mg.append(mag)

np.array(mg)
np.array(dist)
plt.plot(mg,dist,label='Com extinção')
plt.plot(magn,r_pc,linestyle='dotted',label='Sem extinção')
plt.xlabel('Magnitude')
plt.ylabel('Distância [pc]')
plt.legend()

"""## Exercícios do capítulo 3.2

## Física das atmosferas estelares
- Considera-se a radiação de estrelas como uma aproximação  da radiação de um corpo negro.
- Espectos estelares desviam da função de PLanck e o efeito mais importante é a absorção de radiação de camadas mais profundas e mais quentes de uma estrela por gás mais frio em camadas externas. Essas camadas externas que moldam o espectro visível da radiação é a atmosfera estelar.
- Uma importante fonte de absorção em atmosferas estelares são transições de níveis de energia mais baixo para o mais alto.
- Transições do primeiro estado excitado para níveis superiores dão origem a linhas de absorção em espectros estelares, que são conhecidos como linhas de Balmer (absorção mais forte nos espectros de estrelas de classe espectral A).
- Colisões entre átomos excitam alguns deles para um estado de energia mais alto e outros perdem energia.

### Exercício 3.4

letra a
Se assumirmos que o fóton se move em direção
aleatória ao longo de um comprimento constante entre dois
eventos de espalhamento, seu caminho
pode ser descrito pelo chamado passeio aleatório


d = l1 + l2+ l3...+ln

onde cada passo  ln ≡ ( xn , yn ) = (cosθn , sinθn ), com θ n ∈ [0, 2π]


Calculando um passeio aleatório e usando plt.plot() com 'o-' como marcador
para mostrar todas as posições (xn, yn) como pontos conectados por linhas.
"""

#onde p = densidade e k é a opacidade  do gás

p = 1e-6 #g/cm**3
k = 50 #cm**2/g
l = 1/(p*k)

n = np.random.random_sample(size=10)

n1 = 2*np.pi
print(n)

# Em aula l é proporcional a m**n
import matplotlib.pyplot as plt

x = np.zeros(len(n))
y = np.zeros(len(n))


for i in range (len(n)):
    x0 = 0
    y0 = 0

    var_x = l*np.cos(n[i]*n1)
    x[i] = x0
    x[i] = x[i-1] + var_x
    x0 += 1

    var_y = l*np.sin(n[i]*n1)
    y[i] = y0
    y[i] = y[i-1] + var_y
    y0 +=1

    dist = np.abs((x[i]-x0)**2-(y[i]-y0)**2)

print(dist)

print(x)
print()

print(y)

plt.plot(x, y, 'o-')
plt.xlabel("cos (θ)n")
plt.ylabel("sen(θ)n")

"""letra b


"""

# Commented out IPython magic to ensure Python compatibility.
#definindo a função

import numpy as np
from scipy.optimize import curve_fit

#Fazendo em logaritimo
N = np.random.uniform(10, 350, 100)
d = 1/2*np.log10(N)+np.log10(l)


import matplotlib.pyplot as plt
# %matplotlib inline
plt.plot(np.log10(N), np.log10(d), 'o')
plt.xlabel("valores de n")
plt.ylabel("valores de d")

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from scipy.optimize import curve_fit
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

#Fazendo a função sem o logaritmo

l = 1/(p*k)
D = l*np.sqrt(N)
plt.plot(N, D, '.')


#definindo uma função de reta
def fun(N, a, b):
    return a*(N)**1/2 +b

popt, pcov = curve_fit(fun, N, D)
print(popt)


print("a =", popt[0], "+/-", pcov[0,0]**0.5)
print("b =", popt[1], "+/-", pcov[1,1]**0.5)

#plt.errorbar(N, D, yerr=e, fmt="none")
xfine = np.linspace(10, 350., 100)  # define values to plot the function for
plt.plot(xfine, fun(xfine, popt[0], popt[1]), 'r-')

"""## Exercícios do capítulo 3.3

### Exercício 3.5
"""

# Para saber quão rápido é a mudança de duração de dia em \
# minutos para segundos, aplica-se derivada (taxa de variação)


# definindo a função para diferenças centrais
# primeira derivada

def derv_center2(f, x, h):
    return (f(x+h) - f(x-h))/(2*h)

# f é a função de x, são os pontos onde a derivada é computada,\
# e h é a diferença


import astropy.units as u
import numpy as np
from astropy.coordinates import EarthLocation

# Dados da atividade 2.1

# Cálculo para 1 ano (365 dias)
N = np.arange(365)

# Velocidade angular (rad/dia)
omega = 2*np.pi/365.24

# Obliquidade da eclíptica
ecli = np.radians(23.44)

# Excentricidade da orbita da Terra

e = 0.0167

# declinação
delta = -np.arcsin(np.sin(ecli)*\
                   np.cos(omega*(N+10)+e*(2*np.pi/np.pi)*\
                          np.sin(omega*(N-2))))

# Localização do observador
obs = EarthLocation(lat = -10*u.deg + 0.9224*u.arcmin +\
                    0.344*u.arcsec,lon=-37*u.deg + \
                    6*u.arcmin + 5*u.arcsec)

# Latitude
phi = obs.lat

# ângulo horário
h = np.arccos(-np.tan(delta)*np.tan(phi.radian))

# Cálculo da duração de um dia em minutos
T = (np.degrees(2*h)/360) * 60

# para ser dado em uma lista
T1 = [T]

# pontos no horizonte
# transformando T em inteiro
x = np.asarray(T1, dtype=int)
h1 = 0.1

print(" 1ª derv")
for derv in zip(derv_center2(np.sin, x, h)):
    print("{}".format(derv))

"""### Exercício 3.6"""

# Código para coordenadas baricentricas
# A origem das coordenadas baricêntricas \
# é o centro de massa do SS

from astropy.time import Time
from astropy.coordinates import solar_system_ephemeris, \
get_body_barycentric
from astropy import units as u
import numpy as np

solar_system_ephemeris.set('builtin')
a = get_body_barycentric('mars', Time("2022-08-30"))
b = get_body_barycentric('earth', Time("2022-08-30"))
c = a - b

# método para separar as coordenadas e poder calcular a distância
separaçao = c.get_xyz()

# coordenadas
x = separaçao[0]
y = separaçao[1]
z = separaçao[2]

distancia = np.sqrt(x**2+y**2+z**2)
print("Distância Terra Marte = {:.3f}".format(distancia))

noon_cest = Time("2022-01-01")

# array de tempo de dias
elapsed = np.arange(0, 365, 5)*u.day
time = noon_cest + elapsed
print(time)

from astropy.time import Time
from astropy.coordinates import solar_system_ephemeris, \
get_body_barycentric

# Reescrever a diatância Terra Marte \
# usando as coordenadas baricêntricas

def Earth_Mars_dist(time):
    solar_system_ephemeris.set('builtin')
    a = get_body_barycentric('mars', time)
    b = get_body_barycentric('earth', time)
    c = a - b

    # método para separar as coordenadas e poder calcular a distância
    separaçao = c.get_xyz()

    # coordenadas
    x = separaçao[0]
    y = separaçao[1]
    z = separaçao[2]

    distancia = np.sqrt(x**2+y**2+z**2)
    return distancia

import matplotlib.pyplot as plt


plt.figure(figsize=(6,4), dpi=100)
plt.plot(elapsed, Earth_Mars_dist(time+elapsed))
plt.xlabel("time [d]")
plt.ylabel("distance [AU]" )

"""### Exercício 3.8"""

"""
De todos os planetas do sistema solar, qual será a maior distância entre dois planetas ao longo
dos próximos 165 anos

"""

#importando o vsp87.py
import vsop87

import math

def Julian_date(D, M, Y, UT):
    """
    converts day, month, year, and universal time into
    Julian date

    args: D - day
          M - month
          Y - year
          UT - universal time

    returns: Julian date
    """

    if (M <= 2):
        y = Y-1
        m = M+12
    else:
        y = Y
        m = M

    if (Y < 1582):
        B = -2
    elif (Y == 1582):
        if (M < 10):
            B = -2
        elif (M == 10):
            if (D <= 4):
                B=-2
            else:
                B = math.floor(y/400) - math.floor(y/100)
        else:
            B = math.floor(y/400) - math.floor(y/100)
    else:
        B = math.floor(y/400) - math.floor(y/100)

    return math.floor(365.25*y) + math.floor(30.6001*(m+1)) + B + 1720996.5 + D + UT/24

#importando as datas

from datetime import datetime

# fazendo a date em UTC now
now = datetime.utcnow()
print(now)

JD = Julian_date(now.day, now.month, now.year,
                 now.hour + now.minute/60 + now.second/3600)

#fazendo para t para os róximos 165 anos a partir de agora
#t = JD + arange(165*365)
days = 365*165
print(days)
t = JD + np.arange(days)

# convert to Julian date
print("Julian date: {}".format(JD))

#Distância entre Terra e Marte
def Earth_Mars_dist(JD):
    delta_x = vsop87.Earth_X(JD) - vsop87.Mars_X(JD)
    delta_y = vsop87.Earth_Y(JD) - vsop87.Mars_Y(JD)
    delta_z = vsop87.Earth_Z(JD) - vsop87.Mars_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Earth and Mars now: {} AU".format(Earth_Mars_dist(t)))

#Distância entre Terra e Mercurio
def Earth_Mercury_dist(JD):
    delta_x = vsop87.Earth_X(JD) - vsop87.Mercury_X(JD)
    delta_y = vsop87.Earth_Y(JD) - vsop87.Mercury_Y(JD)
    delta_z = vsop87.Earth_Z(JD) - vsop87.Mercury_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)
print("distance between Earth and Mercury now: {} AU".format(Earth_Mercury_dist(t)))

#Distância entre a Terra e Venus

def Earth_Venus_dist(JD):
    delta_x = vsop87.Earth_X(JD) - vsop87.Venus_X(JD)
    delta_y = vsop87.Earth_Y(JD) - vsop87.Venus_Y(JD)
    delta_z = vsop87.Earth_Z(JD) - vsop87.Venus_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)
print("distance between Earth and Venus now: {} AU".format(Earth_Venus_dist(t)))

#Distancia entre a Terra e Jupiter

def Earth_Jupiter_dist(JD):
    delta_x = vsop87.Earth_X(JD) - vsop87.Jupiter_X(JD)
    delta_y = vsop87.Earth_Y(JD) - vsop87.Jupiter_Y(JD)
    delta_z = vsop87.Earth_Z(JD) - vsop87.Jupiter_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Earth and Jupiter now: {} AU".format(Earth_Jupiter_dist(t)))

#Distancia entre a Terra e Saturno

def Earth_Saturn_dist(JD):
    delta_x = vsop87.Earth_X(JD) - vsop87.Saturn_X(JD)
    delta_y = vsop87.Earth_Y(JD) - vsop87.Saturn_Y(JD)
    delta_z = vsop87.Earth_Z(JD) - vsop87.Saturn_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Earth and Saturn now: {} AU".format(Earth_Saturn_dist(t)))

#Distancia entre a Terra e Urano

def Earth_Uranus_dist(JD):
    delta_x = vsop87.Earth_X(JD) - vsop87.Uranus_X(JD)
    delta_y = vsop87.Earth_Y(JD) - vsop87.Uranus_Y(JD)
    delta_z = vsop87.Earth_Z(JD) - vsop87.Uranus_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Earth and Uranus now: {} AU".format(Earth_Uranus_dist(t)))

#Distancia entre a Terra e Netuno

def Earth_Netuno_dist(JD):
    delta_x = vsop87.Earth_X(JD) - vsop87.Neptune_X(JD)
    delta_y = vsop87.Earth_Y(JD) - vsop87.Neptune_Y(JD)
    delta_z = vsop87.Earth_Z(JD) - vsop87.Neptune_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Earth and Neptune now: {} AU".format(Earth_Netuno_dist(t)))

#Distancia entre a Mercurio e Venus

def Mercury_Venus_dist(JD):
    delta_x = vsop87.Mercury_X(JD) - vsop87.Venus_X(JD)
    delta_y = vsop87.Mercury_Y(JD) - vsop87.Venus_Y(JD)
    delta_z = vsop87.Mercury_Z(JD) - vsop87.Venus_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mercury and Venus now: {} AU".format(Mercury_Venus_dist(t)))

#Distancia entre Mercurio e Marte

def Mercury_Mars_dist(JD):
    delta_x = vsop87.Mercury_X(JD) - vsop87.Mars_X(JD)
    delta_y = vsop87.Mercury_Y(JD) - vsop87.Mars_Y(JD)
    delta_z = vsop87.Mercury_Z(JD) - vsop87.Mars_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mercury and Mars now: {} AU".format(Mercury_Mars_dist(t)))

#Distancia entre Mercurio e Jupiter

def Mercury_Jupiter_dist(JD):
    delta_x = vsop87.Mercury_X(JD) - vsop87.Jupiter_X(JD)
    delta_y = vsop87.Mercury_Y(JD) - vsop87.Jupiter_Y(JD)
    delta_z = vsop87.Mercury_Z(JD) - vsop87.Jupiter_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mercury and Jupiter now: {} AU".format(Mercury_Jupiter_dist(t)))

#Distancia entre Mercurio e Saturno

def Mercury_Saturn_dist(JD):
    delta_x = vsop87.Mercury_X(JD) - vsop87.Saturn_X(JD)
    delta_y = vsop87.Mercury_Y(JD) - vsop87.Saturn_Y(JD)
    delta_z = vsop87.Mercury_Z(JD) - vsop87.Saturn_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mercury and Saturn now: {} AU".format(Mercury_Saturn_dist(t)))

#Distancia entre Mercurio e Urano

def Mercury_Uranus_dist(JD):
    delta_x = vsop87.Mercury_X(JD) - vsop87.Uranus_X(JD)
    delta_y = vsop87.Mercury_Y(JD) - vsop87.Uranus_Y(JD)
    delta_z = vsop87.Mercury_Z(JD) - vsop87.Uranus_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mercury and Uranus now: {} AU".format(Mercury_Uranus_dist(t)))

#Distancia entre Mercurio e Netuno
def Mercury_Neptune_dist(JD):
    delta_x = vsop87.Mercury_X(JD) - vsop87.Neptune_X(JD)
    delta_y = vsop87.Mercury_Y(JD) - vsop87.Neptune_Y(JD)
    delta_z = vsop87.Mercury_Z(JD) - vsop87.Neptune_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mercury and Neptune now: {} AU".format(Mercury_Neptune_dist(t)))

#Distancia entre Venus e Marte


def Venus_Mars_dist(JD):
    delta_x = vsop87.Venus_X(JD) - vsop87.Mars_X(JD)
    delta_y = vsop87.Venus_Y(JD) - vsop87.Mars_Y(JD)
    delta_z = vsop87.Venus_Z(JD) - vsop87.Mars_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Venus and Mars now: {} AU".format(Venus_Mars_dist(t)))

#Distancia entre Venus e Jupiter


def Venus_Jupiter_dist(JD):
    delta_x = vsop87.Venus_X(JD) - vsop87.Jupiter_X(JD)
    delta_y = vsop87.Venus_Y(JD) - vsop87.Jupiter_Y(JD)
    delta_z = vsop87.Venus_Z(JD) - vsop87.Jupiter_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Venus and Jupiter now: {} AU".format(Venus_Jupiter_dist(t)))

#Distancia entre Venus e Saturno


def Venus_Saturn_dist(JD):
    delta_x = vsop87.Venus_X(JD) - vsop87.Saturn_X(JD)
    delta_y = vsop87.Venus_Y(JD) - vsop87.Saturn_Y(JD)
    delta_z = vsop87.Venus_Z(JD) - vsop87.Saturn_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Venus and Saturn now: {} AU".format(Venus_Saturn_dist(t)))

#Distancia entre Venus e Urano


def Venus_Uranus_dist(JD):
    delta_x = vsop87.Venus_X(JD) - vsop87.Uranus_X(JD)
    delta_y = vsop87.Venus_Y(JD) - vsop87.Uranus_Y(JD)
    delta_z = vsop87.Venus_Z(JD) - vsop87.Uranus_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Venus and Uranus now: {} AU".format(Venus_Uranus_dist(t)))

#Distancia entre Venus e Netuno


def Venus_Neptune_dist(JD):
    delta_x = vsop87.Venus_X(JD) - vsop87.Neptune_X(JD)
    delta_y = vsop87.Venus_Y(JD) - vsop87.Neptune_Y(JD)
    delta_z = vsop87.Venus_Z(JD) - vsop87.Neptune_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Venus and Neptune now: {} AU".format(Venus_Neptune_dist(t)))

#Distância entre Marte e Jupiter


def Mars_Jupiter_dist(JD):
    delta_x = vsop87.Mars_X(JD) - vsop87.Jupiter_X(JD)
    delta_y = vsop87.Mars_Y(JD) - vsop87.Jupiter_Y(JD)
    delta_z = vsop87.Mars_Z(JD) - vsop87.Jupiter_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mars and Jupiter now: {} AU".format(Mars_Jupiter_dist(t)))

#Distância entre Marte e Saturno


def Mars_Saturn_dist(JD):
    delta_x = vsop87.Mars_X(JD) - vsop87.Saturn_X(JD)
    delta_y = vsop87.Mars_Y(JD) - vsop87.Saturn_Y(JD)
    delta_z = vsop87.Mars_Z(JD) - vsop87.Saturn_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mars and Saturn now: {} AU".format(Mars_Saturn_dist(t)))

#Distância entre Marte e Urano


def Mars_Uranus_dist(JD):
    delta_x = vsop87.Mars_X(JD) - vsop87.Uranus_X(JD)
    delta_y = vsop87.Mars_Y(JD) - vsop87.Uranus_Y(JD)
    delta_z = vsop87.Mars_Z(JD) - vsop87.Uranus_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mars and Uranus now: {} AU".format(Mars_Uranus_dist(t)))

#Distância entre Marte e Netuno


def Mars_Neptune_dist(JD):
    delta_x = vsop87.Mars_X(JD) - vsop87.Neptune_X(JD)
    delta_y = vsop87.Mars_Y(JD) - vsop87.Neptune_Y(JD)
    delta_z = vsop87.Mars_Z(JD) - vsop87.Neptune_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Mars and Neptune now: {} AU".format(Mars_Neptune_dist(t)))

#Distância entre Júpiter e Saturno


def Jupiter_Saturn_dist(JD):
    delta_x = vsop87.Jupiter_X(JD) - vsop87.Saturn_X(JD)
    delta_y = vsop87.Jupiter_Y(JD) - vsop87.Saturn_Y(JD)
    delta_z = vsop87.Jupiter_Z(JD) - vsop87.Saturn_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Jupiter and Saturn now: {} AU".format(Jupiter_Saturn_dist(t)))

#Distância entre Júpiter e Urano


def Jupiter_Uranus_dist(JD):
    delta_x = vsop87.Jupiter_X(JD) - vsop87.Uranus_X(JD)
    delta_y = vsop87.Jupiter_Y(JD) - vsop87.Uranus_Y(JD)
    delta_z = vsop87.Jupiter_Z(JD) - vsop87.Uranus_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Jupiter and Uranus now: {} AU".format(Jupiter_Uranus_dist(t)))

#Distância entre Júpiter e Netuno


def Jupiter_Neptune_dist(JD):
    delta_x = vsop87.Jupiter_X(JD) - vsop87.Neptune_X(JD)
    delta_y = vsop87.Jupiter_Y(JD) - vsop87.Neptune_Y(JD)
    delta_z = vsop87.Jupiter_Z(JD) - vsop87.Neptune_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Jupiter and Neptune now: {} AU".format(Jupiter_Neptune_dist(t)))

#Distância entre Saturno e Urano


def Saturn_Uranus_dist(JD):
    delta_x = vsop87.Saturn_X(JD) - vsop87.Uranus_X(JD)
    delta_y = vsop87.Saturn_Y(JD) - vsop87.Uranus_Y(JD)
    delta_z = vsop87.Saturn_Z(JD) - vsop87.Uranus_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Saturn and Uranus now: {} AU".format(Saturn_Uranus_dist(t)))

#Distância entre Saturno e Netuno


def Saturn_Neptune_dist(JD):
    delta_x = vsop87.Saturn_X(JD) - vsop87.Neptune_X(JD)
    delta_y = vsop87.Saturn_Y(JD) - vsop87.Neptune_Y(JD)
    delta_z = vsop87.Saturn_Z(JD) - vsop87.Neptune_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Saturn and Neptune now: {} AU".format(Saturn_Neptune_dist(t)))

#Distância entre Urano e Netuno


def Uranus_Neptune_dist(JD):
    delta_x = vsop87.Uranus_X(JD) - vsop87.Neptune_X(JD)
    delta_y = vsop87.Uranus_Y(JD) - vsop87.Neptune_Y(JD)
    delta_z = vsop87.Uranus_Z(JD) - vsop87.Neptune_Z(JD)
    return vsop87.np.sqrt(delta_x**2 + delta_y**2 + delta_z**2)

print("distance between Uranus and Neptune now: {} AU".format(Uranus_Neptune_dist(t)))

"""Conclusão, calculando a distância entre dois planetas do sistema solar,
tendo em vista que os planetas estão orbitando ao redor do Sol, daqui a 165 anos,

a maior distância entre dois planetas é equivalente a distância entre Marte e Netuno
"""