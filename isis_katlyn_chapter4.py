# -*- coding: utf-8 -*-
"""isis_katlyn_chapter4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13k8htsNxi_kLVDmeP2-MAgHUuyEQuMLp

## Exercícios do capítulo 4

## Resolvendo equações diferenciais

- Uma equação diferencial de primeira ordem determina o tempo dependendo da função x(f) por uma relação entre a função e sua primeira derivada.
- A logistica da equação de Bernoulli descreve as dinâmicas da população.
- As equações do tipo Bernoulli são importantes porque se conhece uma solução analítica e pode compará-las com aproximações numéricas.
- Uma propagação radial de ionização de quando uma estrela quente e massiva nasce é descrita por uma equação diferencial (equações diferenciais para a astrofíica). A equação 4.3 mostra isso ou 4.4 e 4.5.
- O método de Euler é um método simples de resolver uma equação diferencial de primeira ordem.
- O método de Runge-Kutta é mais sofisticado e preciso. Por exemplo, se o erro for da ordem de dt⁵, ele é preciso até a quarta ordem, chamado RK4.
- Forward: também chamado de argumentos variáveis, pois pode-se passar um número variável de argumentos quando a função é chamada. desvio relativo da solução
- Symplectic: método de primeira ordem; considera um esquema de mudar o passo para calcular a mudança na posição (semi-implícito). O erro típico não aumenta com o tempo.

### Exercício 4.1

#### Solução numérica para o método de Runge-Kutta:
"""

# Solução numérica com derivada

# Pelo método de Runge-Kutta
# definindo o método

def rk4_step(f, t, x, dt):

    k1 = dt * f(t, x)
    k2 = dt * f(t + 0.5*dt, x + 0.5*k1)
    k3 = dt * f(t + 0.5*dt, x + 0.5*k2)
    k4 = dt * f(t + dt, x + k3)

    return x + (k1 + 2*(k2 + k3) + k4)/6

# Função analítica

def x(t,k,x0):
    a = 1/(1-np.exp(-k*t)*((1/x0)-1))
    return a

"""#### Solução analítica:"""

# Computar as soluções da equação de Bernoulli para diferentes valores \
# de k

import numpy as np
import matplotlib.pyplot as plt


# definindo a solução analítica
x0 = 1.5 # valor inicial

t = np.arange(0, 20, 0.01)
k = [0.5, 1.0, 2.0]
for i in k:
    plt.plot(t, x(t,i,x0), label="k = {}".format(i))
plt.xlabel("t")
plt.ylabel("x(t,k)")
plt.legend(loc='lower right')

# Resultado da solução analítica

k = 0.5
print("Solução analítica para k = 0.5, x(t) = ",x(10/0.5, 0.5, 1.5))

k = 1
print("Solução analítica para k = 1.0, x(t) = ",x(10, 1, 1.5))

k = 2
print("Solução analítica para k = 2.0, x(t) = ",x(10/2, 2, 1.5))

# Independente do k, o resultado será o mesmo
# Então, a solução analítica será: x(t) =  0.9999848669190928

x(10, 0.5, 1.5)

"""#### Desvio pelo RK4 e analítico"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline


fig, axs = plt.subplots(2, 1)

k = [0.5, 1.0, 2.0]
for i in k:
    t_max = 10/i
    n_steps = 1

    desvio = np.array([1,1])

    while desvio[-1] >= 1e-3:
        dt = t_max/n_steps

        t = np.linspace(0, t_max, n_steps+1)
        x_rk4 = np.zeros(n_steps+1)
        x0 = 1.1 # valor inicial
        x_rk4[0] = x0

        for n in range(n_steps):
            x_rk4[n+1] = rk4_step(lambda t, x_rk4: (i*x_rk4*(1-x_rk4)),t[n], x_rk4[n], dt)

        xa = (1/(1-np.exp(-i*t)*(((1/x0)-1)))) # analítico

        desvio = abs((x_rk4-xa)/xa)
        print(n_steps,desvio[-1])
        n_steps = n_steps + 1

    if i == 0.5:
        cl = 'red'
    if i == 1.0:
        cl = 'green'
    if i == 2.0:
        cl = 'black'

    axs[1].plot(t,desvio,color=cl,label='k = {}'.format(i))
    axs[0].plot(t, xa,':',color=cl, label='Analítico k = {}'.format(i))
    axs[0].plot(t, x_rk4,'--',color=cl, label='RK4 k = {}'.format(i))

axs[0].legend(bbox_to_anchor=(1, 1))
axs[0].set_xlabel('tempo')
axs[0].set_ylabel('x (t,k)')

axs[1].legend(bbox_to_anchor=(1.25, 1))
axs[1].set_yscale('log')
axs[1].set_xlabel('tempo')
axs[1].set_ylabel('Desvio')

"""- Pelo método de RK4, o número de passos que respeitam o limite é n_steps = 4. Para n_steps = 5 o desvio já é maior que o limite.

#### Desvio pelo método de Euler e analítico
"""

fig, axs = plt.subplots(2, 1)

k = [0.5, 1.0, 2.0]
for i in k:

    t_max = 10/i
    n_steps = 1

    desvio = np.array([1,1])

    while desvio[-1]>=1e-3:
        dt = t_max/n_steps

        t = np.linspace(0, t_max, n_steps+1)
        x_euler = np.zeros(n_steps+1)
        x0 = 1.1 # valor inicial
        x_euler[0] = x0


        for n in range(n_steps):
            xdot = i * x_euler[n] * (1 - x_euler[n])
            x_euler[n+1] = x_euler[n] + xdot * dt
        xa = (1/(1-np.exp(-i*t)*(((1/x0)-1)))) # analítico
        desvio = abs((x_euler-xa)/xa)
        print(n_steps,desvio[-1])
        n_steps = n_steps+1

    if i == 0.5:
        ls = 'red'
    if i == 1.0:
        ls = 'green'
    if i == 2.0:
        ls = 'black'

    axs[1].plot(t,desvio,color=ls,label='k = {}'.format(i))
    axs[0].plot(t, xa,':',color=ls, label='Analítico k = {}'.format(i))
    axs[0].plot(t, x_euler,'--',color=ls, label='Euler k = {}'.format(i))

axs[0].legend(bbox_to_anchor=(1, 1))
axs[0].set_xlabel('tempo')
axs[0].set_ylabel('x (t,k)')

axs[1].legend(bbox_to_anchor=(1.25, 1))
axs[1].set_yscale('log')
axs[1].set_xlabel('tempo')
axs[1].set_ylabel('Desvio')

"""- Para n_steps = 7 o desvio se torna superior ao limite, mas para n_steps = 6, o desvio ainda é menor.

### Exercício 4.2
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline

# Velocidade de propagação X velocidade da luz


import numpy as np
import matplotlib.pyplot as plt
import astropy.units as unit
from astropy.constants import c


fig = plt.figure(figsize=(6, 4), dpi=100)


n0 = 5000 * 1/unit.cm**3
n0_cgs = n0.value

S = 1.6e49 * 1/unit.s
alpha = 3.1e-13 * unit.cm**3/unit.s
alpha_cgs = alpha.value

rs = ((3*S/(4*np.pi * n0**2 * alpha))**(1/3)).value

ts = 1/(n0.value*alpha_cgs) #escala de tempo


n_steps = 1000000
dt = 2*ts/n_steps


t = np.linspace(0, n_steps*dt, n_steps+1)
r = np.zeros(n_steps+1)
r[0] = 1e16
rvetor = [0]


# Euler

for n in range(n_steps):
    rdot = n0_cgs*alpha_cgs*(rs**3-r[n]**3)/(3*r[n]**2)
    rvetor.append(rdot)
    r[n+1] = r[n]+rdot*dt

c = c.value*1e2 # em cm
rvetor = np.array(rvetor)


# plot de r
plt.plot(t/ts, rvetor/c, label = "Euler")
plt.legend(loc='upper right')
plt.xlabel("Tempo $(s)$")
plt.ylabel("Velocidade de propagação ($c$)")
plt.ylim(-0.1,1.0)

"""- A consequência do modelo para o início é que tem velocidades altas e quando t = 0, v tende ao infinito.

### Queda Radial

-

    A queda de um asteroide de alta energia que destruiu quilômetros quadrados de florestas inabitadas. Hoje é conhecido como o evento Tunguska

### Exercício 4.4
"""



"""### Exercício 4.5"""



"""### Exercício 4.6"""



"""### Exercício 4.7"""

# Tempo para cair em um buraco negro
# nave tem v0 = 0 e a = força gravitacional do buraco negro
# Descobrir r(t) para BN estelar e supermassivo
# nave não cruza a esfera r = Rs, pois é o horizonte de eventos

import numpy as np
from astropy.constants import G,M_sun,c

# posição radial no tempo
# rdot = -c*(1-Rs/r)*(Rs/r - Rs/r0)**(1/2) * (1-Rs/r0)**(1/2)

"""#### Letra a"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline


# Buraco negro estelar

M = 10*M_sun.value

# raio de Schwarzschild do buraco negro
Rs = 2*G.value*M/c.value**2 # metros
# raio inicial
r0 = 100*Rs # metros
print("Raio de Schwarzschild = {}".format(Rs))


# passos do tempo
dt = 1e-4
n_steps = 10000

# vetores inicias para t e r(t)
t = np.linspace(0, n_steps*dt, n_steps+1)
r = np.zeros(n_steps+1)

# raio inicial
r0 = 100*Rs
r[0] = r0


# Integração pelo método de Euler
for n in range(n_steps):
    rdot = -c.value*(1-(Rs/r[n]))*(((Rs/r[n]) - (Rs/(r0+1)))**(1/2)) * ((1-(Rs/(r0+1)))**(-1/2))
    r[n+1] = r[n] + rdot*dt


# Condições para nave

r_nave = np.zeros(n_steps+1)
r_nave[0] = r0

for n in range(n_steps):
    rdot_nave = -c.value*(((Rs/r_nave[n]) - (Rs/(r0+1)))**(1/2))
    r_nave[n+1] = r_nave[n] + rdot_nave*dt



import matplotlib.pyplot as plt
# %matplotlib inline

fig = plt.figure(figsize=(6, 4), dpi=100)
plt.plot(t, r*1e-2, linestyle=':' , color='red' , label="para terra")
plt.plot(t, r_nave*1e-2, linestyle='-.' , color='green',label="para nave")
plt.xscale('log')
plt.legend(loc='lower left')
plt.xlabel("$t$ [s]")
plt.ylabel("$r$ [m]")

"""- Ao atingir o ponto r = 0, a nave demorará 10 segundos para ser esmagada e ela ultrapassa o horizonte de eventos aproximadamente no tempo de 0.1 segundos. Já no ponto de vista distante, a neve chega em r = 0 em, aproximadamente, 0.1 segundos e já é destruída, pois ultrapassa o limite.

#### Letra b
"""

# Commented out IPython magic to ensure Python compatibility.
# Buraco negro supermassivo

M = 4e6*M_sun.value

# raio de Schwarzschild do buraco negro
Rs = 2*G.value*M/c.value**2
r0 = 100*Rs
print("Raio de Schwarzschild = {:.2e}".format(Rs))


# passos do tempo
dt = 1e-4
n_steps = 10000

# vetores inicias para t e r(t)
t = np.linspace(0, n_steps*dt, n_steps+1)
r = np.zeros(n_steps+1)

# raio inicial
r0 = 100*Rs
r[0] = r0


# Integração pelo método de Euler
for n in range(n_steps):
    rdot = -c.value*(1-(Rs/r[n]))*(((Rs/r[n]) - (Rs/(r0+1)))**(1/2)) * ((1-(Rs/(r0+1)))**(-1/2))
    r[n+1] = r[n] + rdot*dt


# Condições para nave

r_nave = np.zeros(n_steps+1)
r_nave[0] = r0

for n in range(n_steps):
    rdot_nave = -c.value*(((Rs/r_nave[n]) - (Rs/(r0+1)))**(1/2))
    r_nave[n+1] = r_nave[n] + rdot_nave*dt



import matplotlib.pyplot as plt
# %matplotlib inline

fig = plt.figure(figsize=(6, 4), dpi=100)
plt.plot(t, r*1e-2, linestyle='-.' , color='red' , label="para terra")
plt.plot(t, r_nave*1e-2, linestyle=':' , color='green',label="para nave")
plt.xscale('log')
plt.legend(loc='lower left')
plt.xlabel("$t$ [s]")
plt.ylabel("$r$ [m]")

"""-
    Ao atingir o ponto r = 0, no buraco negro supermassivo, tanto para o referencial nave e longe da nave, ela ultrapassa o horizonte de eventos em 1 segundo e então é destruída.


"""